-- -------------------------------------------------------
-- predefined types
-- -------------------------------------------------------
@DocBrief("The base class for all exceptions")
class exception : object
    @DocBrief("The exception code.")
    private var code : int;
    @DocBrief("The exception message.")
    private var message : string;

    @DocBrief("Gets the exception message.")
    public function getMessage() : string
        return message;
    end

    @DocBrief("Gets the exception code.")
    public function getCode() : int
        return code;
    end

    @DocBrief("Creates an instance of the exception object.")
    @DocParameter("code", "The code of the exception")
    @DocParameter("message", "The exception message")
    public static function create(code : int, message : string) : exception
        var ex : exception;
        ex = new exception();
        ex.code = code;
        ex.message = message;
        return ex;
    end
end


@DocIgnore()
@Cast()
class variantCast
    public static extern fromInt(v : int) : variant;
    public static extern fromReal(v : real) : variant;
    public static extern fromDatetime(v : datetime) : variant;
    public static extern fromBoolean(v : boolean) : variant;
    public static extern fromString(v : string) : variant;
    public static extern fromObject(v : object) : variant;

    public static extern castToInt(v : variant) : int;
    public static extern castToReal(v : variant) : real;
    public static extern castToDatetime(v : variant) : datetime;
    public static extern castToBoolean(v : variant) : boolean;
    public static extern castToString(v : variant) : string;
    public static extern castToObject(v : variant) : object;
end

@DocBrief("The class to convert any primitive type into an object")
@DocDescription("Use the regular `cast` to create an instance of the `variant` object.")
@DocDescription("To convert `nil` constant to a `variant`, first cast `nil` to `object`.")
class variant
    @DocBrief("Return the name of the type")
    @DocDescription("The method returns the same value as `typename` operator for a contained value")
    public extern type() : string;
    
    @DocBrief("Casts and returns the contained value as int")
    public extern asInt() : int;
    
    @DocBrief("Casts and returns the contained value as real")
    public extern asReal() : real;
    
    @DocBrief("Casts and returns the contained value as datetime")
    public extern asDatetime() : datetime;
    
    @DocBrief("Casts and returns the contained value as boolean")
    public extern asBoolean() : boolean;
    
    @DocBrief("Casts and returns the contained value as string")
    public extern asString() : string;
    
    @DocBrief("Casts and returns the contained value as object")
    public extern asObject() : object;

    @DocBrief("Checks whether the contained value is an integer")
    public extern isInt() : boolean;
    
    @DocBrief("Checks whether the contained value is a real")
    public extern isReal() : boolean;
    
    @DocBrief("Checks whether the contained value is a datetime")
    public extern isDatetime() : boolean;
    
    @DocBrief("Checks whether the contained value is a boolean")
    public extern isBoolean() : boolean;
    
    @DocBrief("Checks whether the contained value is a string")
    public extern isString() : boolean;
    
    @DocBrief("Checks whether the contained value is an object")
    public extern isObject() : boolean;
end


@DocBrief("The logger class")
class logger : baseLogger
    @DocBrief("Log trace message")
    @DocParameter("message", "Message to be logged")
    public function trace(message : string) : void
        log(loggerLevel.trace, message);
    end
    @DocBrief("Log debug message")
    @DocParameter("message", "Message to be logged")
    public function debug(message : string) : void
        log(loggerLevel.debug, message);
    end
    @DocBrief("Log information message")
    @DocParameter("message", "Message to be logged")
    public function information(message : string) : void
        log(loggerLevel.information, message);
    end
    @DocBrief("Log warning message")
    @DocParameter("message", "Message to be logged")
    public function warning(message : string) : void
        log(loggerLevel.warning, message);
    end
    @DocBrief("Log error message")
    @DocParameter("message", "Message to be logged")
    public function error(message : string) : void
        log(loggerLevel.error, message);
    end
    @DocBrief("Log error message with exception")
    @DocParameter("message", "Message to be logged")
    @DocParameter("ex", "exception instance")
    public function errorWithException(message : string, ex : exception) : void
        logWithException(loggerLevel.error, message, ex);
    end
    @DocBrief("Log critical message")
    @DocParameter("message", "Message to be logged")
    public function critical(message : string) : void
        log(loggerLevel.critical, message);
    end
    @DocBrief("Log critical message with exception")
    @DocParameter("message", "Message to be logged")
    @DocParameter("ex", "exception instance")
    public function criticalWithException(message : string, ex : exception) : void
        logWithException(loggerLevel.critical, message, ex);
    end
end

@DocBrief("The logger configurator")
class loggerConfigurator : baseLoggerConfigurator
    @DocBrief("Create instance of logger class")
    @DocReturn("The method returns a new logger instance")
    public function createLogger() : logger
        var logger : logger;
        logger = new logger();
        logger.bindConfigurator(this);
        return logger;
    end
end
