class expressionTestSubject
    const c = 1;
    public static function s() : string
        return "2";
    end
end


@TestSuite()
class expressionTest
    @Fact()
    public function typeName() : void
        assert.isTrue(typename(1) == "int", "int");
        assert.isTrue(typename(1.0) == "real", "real");
        assert.isTrue(typename(new int[1]) == "int[]", "primitves array");
        assert.isTrue(typename(stdlib.nowutc()) == "datetime", "datetime");
        assert.isTrue(typename(true) == "boolean", "boolean");
        assert.isTrue(typename(this) == "expressionTest", "class");
        assert.isTrue(typename(new expressionTest[1]) == "expressionTest[]", "primitves array");
    end

    @Fact()
    public function castInt() : void
        assert.isTrue(typename(cast<real>(10)) == "real", "int to real");
        assert.isTrue(cast<real>(10) == 10.0, "int to real");

        assert.isTrue(typename(cast<string>(10)) == "string", "int to string");
        assert.isTrue(cast<string>(10) == "10", "int to string");

        assert.isTrue(typename(cast<datetime>(2459517)) == "datetime", "int to date");
        assert.isTrue(cast<datetime>(2459517) == stdlib.mkdate(2021, 10, 29), "int to date");
    end

    -- TBD: castReal, castString...

    @Fact()
    public function callPriority() : void
        assert.isTrue(2 .. expressionTestSubject.c == "21", "property");
        assert.isTrue(2 .. expressionTestSubject.s() == "22", "method");
    end

    @Fact()
    public function concat() : void
        assert.isTrue("a" .. "b" == "ab", "string to string");
        assert.isTrue("a" .. "b" .. "c" == "abc", "chain");
        assert.isTrue(1 .. "b" == "1b", "int to string");
        assert.isTrue("b" .. 1 == "b1", "string to int");
        assert.isTrue(1 .. 2 == "12", "int to int");
        assert.isTrue(1.5 .. "b" == "1.5b", "real to string");
        assert.isTrue("b" .. 1.5 == "b1.5", "string to real");
    end

    @Fact()
    public function add() : void
        assert.isTrue(1 + 1 == 2, "int1");
        assert.isTrue(-1 + -1 == -2, "int2");
        assert.isTrue(1 + -1 == 0, "int3");

        assert.isTrue(near(1.1 + 1.0, 2.1), "real1");
        assert.isTrue(near(-1.0 + -1.1, -2.1), "real2");
        assert.isTrue(near(1.0 + -1.1, -0.1), "real3");

        assert.isTrue(near(1.1 + 1, 2.1), "mix2");
        assert.isTrue(near(1 + 1.1, 2.1), "mix1");
    end

    @Fact()
    public function subtract() : void
        assert.isTrue(2 - 1 == 1, "int1");
        assert.isTrue(2 - -1 == 3, "int2");
        assert.isTrue(-2 - 1 == -3, "int3");

        assert.isTrue(near(2.0 - 1.1, 0.9), "real1");
        assert.isTrue(near(2.0 - -1.1, 3.1), "real2");
        assert.isTrue(near(-2.0 - 1.1, -3.1), "real3");

        assert.isTrue(near(2.1 - 1, 1.1), "mix1");
        assert.isTrue(near(2 - 1.1, 0.9), "mix1");

    end

    public function negate() : void
        assert.isTrue(-3 == 0 - 3, "int");
        assert.isTrue(near(-3.1, 0.0 - 3.1), "real");
    end

    @Fact()
    public function multiply() : void
        assert.isTrue(1 * 0 == 0, "int1");
        assert.isTrue(1 * 2 == 2, "int2");
        assert.isTrue(5 * 7 == 35, "int3");

        assert.isTrue(near(1.0 * 0.0, 0.0), "real1");
        assert.isTrue(near(1.0 * 2.0, 2.0), "real2");
        assert.isTrue(near(2.0 * 0.25, 0.5), "real3");
        assert.isTrue(near(1.5 * 2.0, 3.0), "real4");
        assert.isTrue(near(5.0 * 7.0, 35.0), "real5");

        assert.isTrue(near(2 * 0.25, 0.5), "mix1");
        assert.isTrue(near(0.25 * 2, 0.5), "mix2");
    end

    @Fact()
    public function divide() : void
        assert.isTrue(0 / 1 == 0, "int1");
        assert.isTrue(1 / 2 == 0, "int2");
        assert.isTrue(4 / 2 == 2, "int3");
        assert.isTrue(5 / 2 == 2, "int4");
        assert.isTrue(125 / 2 == 62, "int5");

        assert.isTrue(near(0.0 / 1.0, 0.0), "real1");
        assert.isTrue(near(1.0 / 2.0, 0.5), "real2");
        assert.isTrue(near(4.0 / 2.0, 2.0), "real3");
        assert.isTrue(near(5.0 / 2.0, 2.5), "real4");
        assert.isTrue(near(125.0 / 2.0, 62.5), "real5");

        assert.isTrue(near(5 / 2.0, 2.5), "mix1");
        assert.isTrue(near(125.0 / 2, 62.5), "mix2");
    end

    @Fact()
    public function modulus() : void
        assert.isTrue(0 % 1 == 0, "int1");
        assert.isTrue(1 % 2 == 1, "int2");
        assert.isTrue(4 % 2 == 0, "int3");
        assert.isTrue(5 % 2 == 1, "int4");
        assert.isTrue(125 % 10 == 5, "int5");

        assert.isTrue(near(0.0 % 1.0, 0), "real1");
        assert.isTrue(near(1.0 % 2.0, 0), "real2");
        assert.isTrue(near(4.0 % 2.0, 0), "real3");
        assert.isTrue(near(5.0 % 2.0, 0), "real4");
        assert.isTrue(near(125.0 % 2.0, 0), "real5");

        assert.isTrue(near(1 % 2.0, 0), "mix1");
        assert.isTrue(near(1.0 % 2, 0), "mix2");
    end

    @Fact()
    public function power() : void
        assert.isTrue(2 ^ 2 == 4, "int1");
        assert.isTrue(3 ^ 5 == 243, "int2");

        assert.isTrue(near(2.0 ^ 2.0, 4.0), "real1");
        assert.isTrue(near(2.5 ^ 2.1, 6.8497389149076081809689669643046), "real2");
    end

    @Fact()
    public function priorityMath() : void
        assert.isTrue(6 / 3 * 4 == 8, "priority1");
        assert.isTrue(6 / 3 + 4 == 6, "priority2");
        assert.isTrue(2 + 3 * 4 == 14, "priority3");
        assert.isTrue((2 + 3) * 4 == 20, "priority4");
        assert.isTrue(3 * 4 + 2 == 14, "priority5");
        assert.isTrue(3 * (4 + 2) == 18, "priority6");
        assert.isTrue(3 * 4 ^ 2 == 48, "priority7");
        assert.isTrue((3 * 4) ^ 2 == 144, "priority8");
    end

    -- TBD: comparison: int to int, real to real, int to real, real to int, string to string, bool to bool
    -- TBD: boolean and, or and not

    @Fact()
    public function nearTest() : void
        assert.isTrue(near(1.0, 1.0), "near1");
        assert.isTrue(near(1.0 / 3.0, 2.0 / 6.0), "near2");

        assert.isFalse(near(1.0 + EPS * 1.1, 1.0), "near3");
        assert.isFalse(near(1.0 - EPS * 1.1, 1.0), "near4");
    end

    const EPS = 0.0000000000001;

    private static function near(v1 : real, v2 : real) : boolean
        var x : real;
        x = v1 - v2;
        if x < 0 then
            x = -x;
        end
        return x < EPS;
    end
end