grammar LuaX
{
    options
    {
        Axiom = "ROOT";
        Separator = "SEPARATOR";
        ParserType = "RNGLR";
    }

    terminals
    {
        NEW_LINE -> U+000D /* CR */
                 |  U+000A /* LF */
                 |  U+000D U+000A /* CR LF */
                 |  U+0085 // Next line character
                 |  U+2028 // Line separator character
                 |  U+2029 ; //Paragraph separator character (U+2029)

        WHITE_SPACE -> U+0020 | U+0009 | U+000B | U+000C | U+000d | U+000a;

        INTEGER -> [0-9] [0-9_]* [0-9]?;

        HEX_INTEGER -> '0' 'x' [0-9A-Fa-f] [0-9A-Fa-f_]* [0-9A-Fa-f]?;

        REAL -> [0-9] [0-9_]* [0-9]? '.' [0-9_]* [0-9]? ([Ee] ('+'|'-')? [0-9] [0-9_]*)?; 

        STRINGDQ -> '"' ( (. - ('"' | '\\')) |
                               ('\\' ('"' | '\\' | 'r' | 'n' | 'b' | 't')) |
                               ('\\' [0-9] [0-9] [0-9]) |
                               ('\\' 'x' [0-9a-fA-F] [0-9a-fA-F])
                        )*  '"';

        COMMENT_LINE    -> '--' (.* - (.* NEW_LINE .*)) ;
        IDENTIFIER  -> [a-zA-Z_] [a-zA-Z0-9_]* ;
        SEPARATOR   -> WHITE_SPACE | COMMENT_LINE | NEW_LINE;
    }

    rules {
        NIL -> 'nil'!;

        BOOLEAN_TRUE -> 'true'!;

        BOOLEAN_FALSE -> 'false'!;

        BOOLEAN -> BOOLEAN_TRUE | BOOLEAN_FALSE;

        STRING -> STRINGDQ;

        NEGATIVE_INTEGER -> '-'! INTEGER;

        NEGATIVE_REAL -> '-'! REAL;

        CONSTANT -> NIL |
                    BOOLEAN |
                    STRING |
                    INTEGER |
                    HEX_INTEGER |
                    NEGATIVE_INTEGER | 
                    REAL |
                    NEGATIVE_REAL;

        TYPE_INT -> 'int'!;

        TYPE_REAL -> 'real'!;

        TYPE_BOOLEAN -> 'boolean'!;

        TYPE_STRING -> 'string'!;

        TYPE_VOID -> 'void'!;

        TYPE_CLASS -> IDENTIFIER;


        TYPE_NAME -> TYPE_INT |
                     TYPE_REAL |
                     TYPE_BOOLEAN |
                     TYPE_STRING |
                     TYPE_VOID | 
                     IDENTIFIER;

        TYPE_DECL -> TYPE_NAME ARRAY_DECL?;

        DECL -> IDENTIFIER ':'! TYPE_DECL;

        DECL_LIST -> DECL (','! DECL)*;

        ARRAY_DECL -> '['! ']'!;

        VARIABLE -> IDENTIFIER;

        PROPERTY -> CALLABLE_EXPR '.'! IDENTIFIER;

        ARRAY_ELEMENT -> CALLABLE_EXPR '['! EXPR ']'!;

        ASSIGN_TARGET -> VARIABLE | PROPERTY | ARRAY_ELEMENT;

        CALL_ARGS -> REXPR (','! REXPR)*;

        CALL_BRACKET -> '('! CALL_ARGS? ')'!;

        LOCAL_CALL -> IDENTIFIER CALL_BRACKET;

        METHOD_CALL -> REXPR '.'^ IDENTIFIER CALL_BRACKET;

        CALL -> LOCAL_CALL | METHOD_CALL;

        FIELD_ASSIGNMENT -> IDENTIFIER '='! REXPR;

        NEW_ARRAY_EXPR -> 'new'! TYPE_NAME '['! REXPR ']'!;

        NEW_TABLE_EXPR -> 'new'! IDENTIFIER '('! ')'!;

        METHOD -> CALLABLE_EXPR ':'! IDENTIFIER;

        CALLABLE_EXPR -> ASSIGN_TARGET |
                         METHOD |
                         CALL;

        BRACKET_EXPR -> '('! EXPR ')'!;

        SIMPLE_EXPR -> CONSTANT |
                       CALLABLE_EXPR |
                       BRACKET_EXPR;

        MINUS_OP -> '-'!;

        PLUS_OP -> '+'!;

        UNARY_EXPR -> SIMPLE_EXPR |
                      MINUS_OP^ SIMPLE_EXPR |
                      PLUS_OP^ SIMPLE_EXPR;

        POWER_OP -> '^'!;

        POWER_EXPR -> UNARY_EXPR |
                      POWER_EXPR POWER_OP^ UNARY_EXPR;

        MUL_OP -> '*'!;
        DIV_OP -> '/'!;
        REM_OP -> '%'!;

        MUL_EXPR -> POWER_EXPR |
                    MUL_EXPR MUL_OP^ POWER_EXPR |
                    MUL_EXPR DIV_OP^ POWER_EXPR |
                    MUL_EXPR REM_OP^ POWER_EXPR;

        CONCAT_OP -> '..'!;


        ADD_EXPR -> MUL_EXPR |
                    ADD_EXPR CONCAT_OP^ MUL_EXPR |
                    ADD_EXPR PLUS_OP^ MUL_EXPR |
                    ADD_EXPR MINUS_OP^ MUL_EXPR;

        EQ_OP -> '=='!;
        NEQ_OP -> '~='!;
        GT_OP -> '>'!;
        GE_OP -> '>='!;
        LT_OP -> '<'!;
        LE_OP -> '<='!;

        REL_EXPR -> ADD_EXPR |
                    REL_EXPR EQ_OP^ ADD_EXPR |
                    REL_EXPR NEQ_OP^ ADD_EXPR |
                    REL_EXPR GT_OP^ ADD_EXPR |
                    REL_EXPR GE_OP^ ADD_EXPR |
                    REL_EXPR LT_OP^ ADD_EXPR |
                    REL_EXPR LE_OP^ ADD_EXPR;

        NOT_OP -> 'not'!;
        AND_OP -> 'and'!;
        OR_OP -> 'or'!;

        UX_BOOL_EXPR -> REL_EXPR |
                        NOT_OP^ REL_EXPR;

        AND_BOOL_EXPR -> UX_BOOL_EXPR |
                         AND_BOOL_EXPR AND_OP^ UX_BOOL_EXPR;

        OR_BOOL_EXPR -> AND_BOOL_EXPR |
                        OR_BOOL_EXPR OR_OP^ AND_BOOL_EXPR;

        EXPR -> OR_BOOL_EXPR;

        EOS -> ';'!;

        NOP -> EOS;

        REXPR -> EXPR | NEW_ARRAY_EXPR | NEW_TABLE_EXPR;

        ASSIGN_STMT -> ASSIGN_TARGET '='! REXPR EOS!;

        DECLARATION -> 'var'! DECL_LIST EOS!;

        RETURN_STMT ->  'return'! REXPR? EOS!;

        CATCH -> 'catch'! IDENTIFIER STATEMENTS;

        TRY_STMT -> 'try'! STATEMENTS CATCH 'end'!;

        CALL_STMT -> CALL EOS!;

        ELSEIF_CLAUSE -> 'elseif'! EXPR 'then'! STATEMENTS ;

        ELSE_CLAUSE -> 'else'!  STATEMENTS ;

        IF_CLAUSE -> 'if'!  EXPR 'then'!  STATEMENTS ;

        IF_STMT ->  IF_CLAUSE
                    ELSEIF_CLAUSE*
                    ELSE_CLAUSE?
                    'end'! EOS!;

        WHILE_STMT -> 'while'! EXPR 'do'! STATEMENTS 'end'!;

        REPEAT_STMT -> 'repeat'!  STATEMENTS 'until'! EXPR;

        FOR_STMT_LOOP -> IDENTIFIER '='! EXPR ','! EXPR (','! EXPR)?;

        FOR_STMT -> 'for' FOR_STMT_LOOP 'do'! STATEMENTS 'end'!;

        FORIN_STMT_LOOP -> IDENTIFIER 'in'! EXPR;

        FOR_IN_STMT -> 'for'! FORIN_STMT_LOOP 'do'! STATEMENTS 'end'!;

        BREAK_STMT -> 'break'! EOS!;

        CONTINUE_STMT -> 'continue'! EOS!;

        STATEMENT -> DECLARATION |
                     ASSIGN_STMT |
                     RETURN_STMT |
                     CALL_STMT |
                     IF_STMT |
                     WHILE_STMT |
                     REPEAT_STMT |
                     FOR_STMT |
                     FOR_IN_STMT |
                     BREAK_STMT |
                     CONTINUE_STMT |
                     TRY_STMT |
                     NOP;

        STATEMENTS -> STATEMENT* ;

        FUNCTION_DECLARATION_ARGS -> '('! DECL_LIST? ')'!;

        CONSTANTS -> CONSTANT (','! CONSTANT)*;

        ATTRIBUTE -> '@'! IDENTIFIER '('! CONSTANTS? ')'!;

        ATTRIBUTES -> ATTRIBUTE ATTRIBUTE*;

        STATIC -> 'static'!;

        VISIBILITY_PUBLIC -> 'public'!;

        VISIBILITY_PRIVATE -> 'private'!;

        VISIBILITY -> VISIBILITY_PUBLIC | VISIBILITY_PRIVATE;

        FUNCTION_DECLARATION -> ATTRIBUTES? VISIBILITY? STATIC? 'function'! IDENTIFIER FUNCTION_DECLARATION_ARGS ':'! TYPE_DECL STATEMENTS? 'end'!;

        PARENT_CLASS -> ':'! IDENTIFIER;

        PROPERTY -> VISIBILITY? STATIC? DECLARATION;

        CLASS_ELEMENT -> PROPERTY | FUNCTION_DECLARATION;

        CLASS_DECLARATION -> ATTRIBUTES? 'class'! IDENTIFIER PARENT_CLASS? CLASS_ELEMENT* 'end'!;
        
        ROOT -> CLASS_DECLARATION*;
    }
}